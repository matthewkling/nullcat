% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantize_commsim.R
\name{quantize_commsim_seq}
\alias{quantize_commsim_seq}
\title{Quantile-based quantize commsim (sequential / Markov chain)}
\usage{
quantize_commsim_seq(...)
}
\arguments{
\item{...}{Arguments passed to [quantize()], such as `breaks`,
`n_strata`, `transform`, `offset`, `zero_stratum`, `fixed`,
`method`, `n_iter`, etc. Do **not** supply `x` or `n_iter` here;
`x` is provided by vegan and `n_iter` is set internally from
`thin`. See [quantize()] for details.}
}
\value{
An object of class `"commsim"` suitable for
  [vegan::nullmodel()] and [vegan::oecosimu()].
}
\description{
Construct a [vegan::commsim()] object that uses [quantize()] as a
*sequential* null model: successive simulated matrices form a
Markov chain in the space of numeric community matrices.
Internally, each simulation "step" advances the chain by
re-applying [quantize()] to the current matrix using the settings
provided via `...`.
}
\section{Details}{


This model is **sequential**: simulated matrices form a Markov chain. The current matrix is
updated in-place by repeated calls to the randomization model, and successive
matrices are obtained by advancing the chain.

In `vegan::simulate.nullmodel()`, the control arguments behave as:
\itemize{
  \item `nsim`: number of matrices to *store* from the chain.
  \item `thin`: number of trades per step. Each "step" of the chain
  applies `thin` trades of the chosen `method` to the current state
  before possibly storing it.
  \item `burnin`: number of initial steps to perform (each with `thin`
  trades) before storing any matrices, i.e. the Markov chain
  burn-in.
}

There is no `n_iter` argument here: mixing is controlled entirely by
`thin` (trades per step) and `burnin` (number of initial steps
discarded), in the same spirit as sequential swap / curveball models
in **vegan**.
}

\examples{
\dontrun{
  library(vegan)

  x <- matrix(rexp(50), 10, 5)

  cs <- quantize_commsim_seq(
    n_strata = 10,
    method   = "curvecat",
    n_iter   = 1000L
  )

  nm <- nullmodel(x, cs)

  sims <- simulate(
    nm,
    nsim   = 999,
    thin   = 10,    # 10 quantize updates between stored states
    burnin = 100    # 100 initial steps discarded
  )
}

}
