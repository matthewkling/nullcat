% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantize.R
\name{quantize}
\alias{quantize}
\title{Stratified randomization of a quantitative community matrix}
\usage{
quantize(
  x = NULL,
  prep = NULL,
  method = "curvecat",
  breaks = NULL,
  n_strata = NULL,
  transform = NULL,
  offset = NULL,
  zero_stratum = NULL,
  ...
)
}
\arguments{
\item{x}{Community matrix with sites in rows, species in columns, and
nonnegative quantitative values in cells. Ignored if \code{prep} is
supplied.}

\item{prep}{Optional precomputed object returned by
\code{\link{quantize_prep}}. If supplied, \code{x} is ignored and all
overhead (stratification, pools, etc.) is taken from \code{prep}, which
is typically much faster when generating many randomizations of the same
dataset.}

\item{method}{Character string specifying the null model algorithm.
The default \code{"curvecat"} uses the categorical curveball algorithm
(see \code{\link{curvecat}}). Any of the binary methods listed in
\code{\link[vegan]{commsim}} (e.g. \code{"curveball"}, \code{"swap"},
\code{"tswap"}, \code{"quasiswap"}, \code{"backtracking"}, \dots) can also
be used; these are applied to a binary representation of each stratum via
\code{\link[vegan]{nullmodel}}. Only binary methods should be used here.}

\item{...}{Additional arguments controlling stratification, quantitative
reassignment, and (for vegan methods) the underlying binary null model:
\itemize{
  \item \code{priority}: One of \code{"rows"}, \code{"cols"}, or
    \code{"neither"}, indicating whether reassignment of quantitative
    values within strata should prioritize maintaining the marginal
    distributions of rows or columns of the input matrix. The default,
    \code{"neither"}, does not give precedence to either dimension.
    Note that this interacts with \code{method}: different null models
    fix different margins in the underlying binary representation.
  \item \code{n_iter}: For \code{method = "curvecat"}, the number of
    categorical curveball iterations (row-pair trades) to perform.
    Larger values yield more thorough mixing. If omitted, a data-dependent
    default is used.
  \item Other arguments are passed on to
    \code{\link[vegan]{simulate.nullmodel}} for binary methods, such as
    \code{seed} or \code{burnin}. The default \code{burnin} is
    \code{10000}. Arguments \code{nsim} and \code{thin} are ignored, as
    they are internally set to \code{1}.
}}
}
\value{
A randomized version of \code{x}, with the same dimensions and
  dimnames. For \code{method = "curvecat"}, the quantitative values are
  reassigned within strata while preserving row and column stratum
  multisets. For binary methods, the result corresponds to applying the
  chosen binary null model to each stratum and recombining.
}
\description{
\code{quantize()} is a community null model for quantitative community data
(e.g. abundance, biomass, or occurrence probability). It works by converting
quantitative values into a small number of categorical strata, randomizing
the categorical layout under a chosen null model, and then reassigning
quantitative values within each stratum.
}
\details{
Two classes of null model are supported:

\itemize{
  \item \strong{\code{method = "curvecat"}} (the default) uses the
  categorical curveball algorithm implemented in \code{\link{curvecat}}.
  This preserves the multiset of strata in each row and column, and
  reassigns quantitative values within those strata according to
  \code{priority}.

  \item \strong{Binary vegan methods} (e.g. \code{"curveball"}, \code{"swap"},
  \code{"quasiswap"}, etc.) are accessed via \code{\link[vegan]{nullmodel}}.
  In this case the matrix is decomposed into a stack of binary layers
  (one per stratum), each layer is randomized with the chosen binary method,
  and the layers are recombined to yield a quantitative matrix. This
  reproduces classical binary null models on each stratum while approximately
  preserving the marginal distributions of rows and columns in the
  quantitative data. Because strata are permuted independently, the "one-hot"
  property in which a given species-site has occupancy in exactly one stratum
  is not maintained; this can lead, e.g., to probabilities grater than 1.
}

By default, \code{quantize()} will compute all necessary overhead for a
given dataset (strata, pools, etc.) internally. For repeated randomization
of the same matrix (e.g. to build a null distribution), this overhead can be
computed once using \code{\link{quantize_prep}} and reused by supplying the
resulting object via the \code{prep} argument.
}
\examples{
\donttest{
# toy quantitative community matrix
set.seed(1)
comm <- matrix(rexp(50 * 40), nrow = 50,
               dimnames = list(paste0("site", 1:50),
                               paste0("sp", 1:40)))

# default: curvecat-backed stratified randomization
rand1 <- quantize(comm)

# change stratification and priority
rand2 <- quantize(comm, n_strata = 4,
                  transform = sqrt,
                  priority  = "rows",
                  n_iter    = 2000)

# use a vegan binary method on each stratum (here: swap)
rand3 <- quantize(comm, method = "swap",
                  n_strata = 5,
                  burnin   = 10000)

# precompute overhead and reuse for many randomizations
prep  <- quantize_prep(comm, method = "curvecat",
                       n_strata = 5, priority = "rows")
rand4 <- quantize(prep = prep)
rand5 <- quantize(prep = prep)
}

}
