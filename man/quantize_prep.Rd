% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantize.R
\name{quantize_prep}
\alias{quantize_prep}
\title{Prepare stratified null model overhead for quantize()}
\usage{
quantize_prep(
  x,
  method = "curvecat",
  fixed = c("stratum", "cell", "row", "col"),
  breaks = NULL,
  n_strata = 5,
  transform = identity,
  offset = 0,
  zero_stratum = FALSE,
  ...
)
}
\arguments{
\item{x}{Community matrix with sites in rows, species in columns, and
nonnegative quantitative values in cells.
This is the dataset for which stratification and null model overhead
should be prepared.}

\item{method}{Character string specifying the null model algorithm.
The default \code{"curvecat"} uses the categorical curveball algorithm.
See \code{\link{nullcat}} for alternative options.}

\item{fixed}{Character string specifying the level at which quantitative
  values are held fixed during randomization. One of:
  \itemize{
    \item \code{"stratum"} (the default):
      values are shuffled globally within each stratum, holding only the overall
      stratum-level value distribution fixed.
    \item \code{"cell"} (only available when \code{method = "curvecat"}):
      values remain attached to their original cells and move with them during
      the categorical randomization. Row and column value
      distributions are not preserved, but the mapping between each original
      cell and its randomized destination is fixed.
    \item \code{"row"}: values are shuffled within strata separately for each
      row, holding each row’s value multiset fixed.
    \item \code{"col"}: values are shuffled within strata separately for each
      column, holding each column’s value multiset fixed.
}
Note that this interacts with \code{method}: different null models
fix different margins in the underlying binary representation.}

\item{breaks}{Numeric vector of stratum breakpoints.}

\item{n_strata}{Integer giving the number of strata to split the
data into. Must be 2 or greater. Larger values yield randomizations
with less mixing but higher fidelity to the original marginal
distributions. Default is \code{5}. Ignored unless \code{breaks = NULL}.}

\item{transform}{A function used to transform the values in
\code{x} before assigning them to \code{n_strata} equal-width
intervals. Examples include \code{sqrt}, \code{log}, \code{rank}, etc.;
the default is \code{identity}. If \code{zero_stratum = TRUE}, the
transformation is only applied on nonzero values. The function should
pass NA values. This argument is ignored unless \code{breaks = NULL}.}

\item{offset}{Numeric value between -1 and 1 (default 0) indicating
how much to shift stratum breakpoints relative to the binwidth (applied
during quantization as: \code{breaks <- breaks + offset * bw}). To
assess sensitivity to stratum boundaries, run \code{quantize()} multiple
times with different offset values. Ignored unless \code{breaks = NULL}.}

\item{zero_stratum}{Logical indicating whether to segregate zeros into their
own stratum. If \code{FALSE} (the default), zeros will likely be combined
into a stratum that also includes small positive numbers. If \code{breaks} iss
specified, zero simply gets added as an additional break; if not, one
of the \code{n_strata} will represent zeros and the others will be nonzero ranges.}

\item{...}{Additional arguments controlling stratification, quantitative
reassignment, and (for vegan methods) the underlying binary null model:
\itemize{
  \item \code{n_iter}: For \code{method = "curvecat"}, the number of
    categorical curveball iterations (row-pair trades) to perform.
    Larger values yield more thorough mixing. If omitted, a data-dependent
    default is used.
  \item Other arguments are passed on to
    \code{\link[vegan]{simulate.nullmodel}} for binary methods, such as
    \code{seed} or \code{burnin}. The default \code{burnin} is
    \code{10000}. Arguments \code{nsim} and \code{thin} are ignored, as
    they are internally set to \code{1}.
}}
}
\value{
A list with class \code{"quantize_prep"} (if you want to set it)
  containing the components needed by \code{\link{quantize}()}:
  \itemize{
    \item \code{strata}: integer matrix of the same dimension as \code{x},
      giving the stratum index (1, \dots, \code{n_strata}) for each cell.
    \item \code{stratarray}: for binary methods, a 3D array of dimension
      \code{n_strata} × \code{nrow(x)} × \code{ncol(x)} containing the
      binary incidence matrix for each stratum; \code{NULL} for
      \code{method = "curvecat"}.
    \item \code{pool}: data structure encoding the quantitative value pools
      used during reassignment. For \code{"curvecat"}, this is a list of
      per-stratum or per-row/column pools depending on \code{fixed}; for
      binary methods, it is a matrix of pre-shuffled values.
    \item \code{method}: the null model method used (as in the
      \code{method} argument).
    \item \code{n_strata}, \code{transform}, \code{offset}, \code{fixed}:
      the stratification and reassignment settings used to construct
      \code{strata} and \code{pool}.
    \item \code{sim_args}: named list of arguments to be passed on to
      \code{\link[vegan]{simulate.nullmodel}} (for binary methods) or used
      internally by \code{curvecat} (e.g. \code{n_iter}).
  }

  This object is intended to be passed unchanged to \code{\link{quantize}()}
  via its \code{prep} argument.
}
\description{
\code{quantize_prep()} precomputes all of the stratification and bookkeeping
needed by \code{\link{quantize}()} for a given quantitative community
matrix. This is useful when you want to generate many randomizations of the
same dataset: the expensive steps (strata assignment, value pools, and
arguments for the underlying null model) are computed once, and the resulting
object can be passed to \code{quantize(prep = ...)} for fast repeated draws.
}
\details{
Internally, \code{quantize_prep()}:
\itemize{
  \item transforms and stratifies \code{x} into \code{n_strata} numeric
    intervals (via \code{\link{stratify}()}),
  \item constructs the appropriate value pools given \code{fixed}
    (either for the categorical \code{"curvecat"} backend or for binary
    vegan methods), and
  \item assembles arguments for the underlying null model call
    (\code{\link{curvecat}} or \code{\link[vegan]{simulate.nullmodel}}).
}
The returned object can be reused across calls to \code{\link{quantize}()},
\code{\link{quantize_null}()}, or other helpers that accept a \code{prep}
argument.
}
\examples{
\donttest{
set.seed(1)
comm <- matrix(rexp(50 * 40), nrow = 50,
               dimnames = list(paste0("site", 1:50),
                               paste0("sp",   1:40)))

# prepare overhead for a curvecat-backed stratified null model
prep <- quantize_prep(comm, method   = "curvecat",
                      n_strata = 5,
                      fixed = "row",
                      n_iter   = 2000)

# fast repeated randomizations using the same prep
rand1 <- quantize(prep = prep)
rand2 <- quantize(prep = prep)

# use a binary vegan method on each stratum
prep_bin <- quantize_prep(comm, method = "swap",
                          n_strata = 4,
                          burnin   = 10000)
rand3 <- quantize(prep = prep_bin)
}

}
